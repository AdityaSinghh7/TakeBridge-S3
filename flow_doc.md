End-To-End Flow

OAuth start → finalize: the FastAPI route builds a deterministic redirect, calls OAuthManager.start_oauth, and hands the user a Composio URL keyed by X-User-Id (defaults to singleton) so different tenants could coexist if callers ever pass real ids (framework/api/routes_mcp_auth.py (line 23), framework/api/routes_mcp_auth.py (line 25), framework/mcp/oauth.py (line 71)). After Composio redirects back with a connectedAccountId, /api/composio-redirect finalizes the account, forces a sync, refreshes the MCP registry, and re-registers actions so new tools show up immediately (framework/api/route_composio_redirect.py (line 13), framework/mcp/oauth.py (line 123), framework/mcp/oauth.py (line 267), framework/mcp/registry.py (line 10), framework/mcp/actions.py (line 361)). The lifecycle mirrors the doc’s six-stage sequence (MCP_DB_INTEGRATION.md (line 124)).
Persistence as source of truth: OAuthManager.finalize_connected_account polls Composio until the account is ACTIVE, normalizes the MCP URL/headers (minting tokens and adding connected_account_ids/user_id query params and X-Connected-Account-Id headers), then upserts User, AuthConfig, ConnectedAccount, and MCPConnection within a session_scope transaction so the DB always holds the canonical endpoint plus auth material (framework/mcp/oauth.py (line 123), framework/db/engine.py (line 24), framework/db/models.py (line 18), framework/db/crud.py (line 15)). Disconnect routes simply flip statuses and clear stored URLs so is_authorized immediately returns false (framework/api/routes_mcp_auth.py (line 96), framework/db/crud.py (line 170)).
Registry and action surfacing: init_registry rebuilds the global MCP dict for the current user by reading DB rows and constructing MCPClient objects with OAuthManager.get_headers, while falling back to env-provided URLs/tokens when no DB entry exists (framework/mcp/registry.py (line 10), framework/mcp/oauth.py (line 225)). register_mcp_actions wipes any stale methods on the grounding agent base class (ACI) and attaches only the provider functions that are simultaneously authorized (DB) and registered (MCP client present), keeping the worker prompt honest (framework/mcp/actions.py (line 313), framework/grou​nding/grounding_agent.py (line 8)). This matches the doc’s emphasis on DB-driven resiliency across restarts (MCP_DB_INTEGRATION.md (line 152)).
Runtime invocation: When the worker plans an MCP step (e.g., agent.gmail_send_email), create_pyautogui_code evals the method immediately; the method checks OAuthManager.is_authorized, calls the cached MCPClient via MCPAgent, records telemetry, and returns a simple sleep snippet so the remote controller just waits while the real work already happened server-side (framework/mcp/actions.py (line 11), framework/mcp/actions.py (line 88), framework/mcp/mcp_agent.py (line 55), framework/mcp/mcp_client.py (line 49)). Runner still executes the returned snippet for consistency but tags the step as mcp, which suppresses behavior narration and tells later prompts to summarize the MCP outcome instead of expecting a GUI change (framework/worker/worker.py (line 822), framework/orchestrator/runner.py (line 311)).
Key Components

OAuthManager: wraps every Composio touchpoint (create connection, poll, provision MCP servers, generate per-account URLs/tokens, sync with TTL caching) and always enriches headers with Authorization, X-Connected-Account-Id, and X-Auth-Config-Id while falling back to COMPOSIO_TOKEN when needed (framework/mcp/oauth.py (line 71), framework/mcp/oauth.py (line 225), framework/mcp/oauth.py (line 275)). _store throttles syncs (30‑second freshness check) yet force-syncs whenever routes call it, aligning with the doc’s service-layer description (MCP_DB_INTEGRATION.md (line 68)).
Database layer: models capture tenancy (user_id on ConnectedAccount), enforce unique (user, auth_config) pairs to prevent duplicates, and keep JSON headers alongside each MCP URL, while CRUD helpers guarantee idempotent upserts and safe disconnect semantics (framework/db/models.py (line 18), framework/db/crud.py (line 38)). All DB access goes through session_scope to ensure commits/rollbacks stay short-lived (framework/db/engine.py (line 24)).
Registry + MCPClient: The registry is global per process but rebuilt per user id, and each MCPClient uses the official MCP HTTP transport (streamablehttp_client + ClientSession) to initialize, list tools defensively, and call tools synchronously via asyncio.run, logging redacted headers for auditability (framework/mcp/registry.py (line 10), framework/mcp/mcp_client.py (line 30), framework/mcp/mcp_client.py (line 49)). Debug routes expose this state for troubleshooting (framework/api/routes_mcp_auth.py (line 220)).
MCP actions: Decorated methods live in framework/mcp/actions.py, rely on _sleep_snippet to keep controller timelines predictable, emit instrumentation when authorization is missing, and register themselves onto ACI at import time so the worker prompt already contains the right docstrings (sanitized to avoid leaking “API/MCP” terminology) (framework/mcp/actions.py (line 11), framework/mcp/actions.py (line 46), framework/worker/worker.py (line 75)).
MCPAgent + worker integration: MCPAgent owns per-run history, step tracking, and telemetry (current step is set before each plan and finalized after execution), while the worker injects the last MCP outcome into both the reflection loop and the next generator prompt so the LLM can reason over remote tool output (framework/mcp/mcp_agent.py (line 34), framework/mcp/mcp_agent.py (line 55), framework/worker/worker.py (line 195), framework/worker/worker.py (line 420), framework/worker/worker.py (line 591), framework/worker/worker.py (line 786)). Metrics like mcp_history_count are emitted for observability (framework/worker/worker.py (line 790)).
Runner/orchestrator: Importing framework.mcp.actions as a side effect ensures the grounding agent class already exposes any authorized MCP methods before the worker is instantiated; each run creates a fresh MCPAgent, wires it into the global singleton, and propagates action_kind back from the worker so GUI-vs-MCP steps can be handled differently (framework/orchestrator/runner.py (line 11), framework/orchestrator/runner.py (line 114), framework/orchestrator/runner.py (line 168), framework/orchestrator/runner.py (line 311), framework/orchestrator/runner.py (line 344)).
API + server glue: OAuth routes cover start, callback, finalize, disconnect, status, and multiple _debug/* helpers (redirect preview, Composio ping, auth-config listing, DB counts, MCP client inspection, Composio connected accounts) while honoring X-User-Id (framework/api/routes_mcp_auth.py (line 23), framework/api/routes_mcp_auth.py (line 58), framework/api/routes_mcp_auth.py (line 121), framework/api/routes_mcp_auth.py (line 248)). The white-label redirect endpoint handles both phases of the Composio flow (framework/api/route_composio_redirect.py (line 13)). The FastAPI lifespan hook re-syncs Gmail/Slack and refreshes the registry on startup so cached MCP clients survive restarts (framework/api/server.py (line 54)). A test-only Gmail send route exercises the MCP client stack without invoking the worker (framework/api/routes_mcp_tools.py (line 17)).
Operational & Tenancy Notes

Everything defaults to the singleton tenant unless an X-User-Id header is forwarded; the schema, OAuthManager APIs, and routes are already parameterized by user, but the registry and ACI bindings remain global, which is why the doc calls the current system “effectively single-tenant” and outlines the steps needed for real multi-tenancy (per-user registries, user-aware worker runs, cache partitioning) (MCP_DB_INTEGRATION.md (line 159), framework/mcp/registry.py (line 12)).
Environment variables drive connectivity (COMPOSIO_API_KEY, COMPOSIO_*_AUTH_CONFIG_ID, COMPOSIO_REDIRECT, COMPOSIO_MCP_SERVER_ID, DB_URL, etc.), and the operational notes highlight that server warm restarts automatically call OAuthManager.sync/refresh_registry_from_oauth to repopulate state plus expose _debug routes for triage (MCP_DB_INTEGRATION.md (line 196), framework/api/server.py (line 54), framework/api/routes_mcp_auth.py (line 140)).
_sync_connection caches the last successful pull per provider/user and skips redundant polling for 30 seconds, but force-syncs are triggered after OAuth finalize, on status checks, at startup, and inside the test routes, giving a balance between staying fresh and not overloading Composio (framework/mcp/oauth.py (line 267), framework/api/routes_mcp_auth.py (line 58), framework/api/routes_mcp_tools.py (line 33)).
Next Steps

If you plan to support multiple end users, start threading real X-User-Id values through the orchestrator/worker layers and splitting the MCP registry + ACI bindings per user, as outlined in the tenancy section of the doc (MCP_DB_INTEGRATION.md (line 172)).
Exercise the _debug/mcp_client and /api/mcp/tools/gmail/send_email routes after connecting providers to validate that DB state, headers, and Composio MCP servers are in sync before running full worker jobs (framework/api/routes_mcp_auth.py (line 220), framework/api/routes_mcp_tools.py (line 17)).